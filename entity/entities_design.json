{"primary_entities": [{"entity_name": "search", "endpoints": {"POST": [{"endpoint": "/api/companies/search", "description": "Create a new search.", "complete_code_for_action_derived_from_the_prototype": "\n    \"\"\"\n    POST endpoint that accepts a JSON payload with a companyName.\n    It performs an external search, filters active companies, enriches them with LEI data,\n    caches the results via entity_service.add_item, and returns a response including a searchId.\n    \"\"\"\n    company_name = data.companyName\n    if not company_name:\n        return jsonify({\"error\": \"companyName is required\"}), 400\n\n    # Step 1: Fetch companies from the external PRH API.\n    companies = await fetch_companies(company_name)\n    if not companies:\n        return jsonify({\"error\": \"No companies found or error fetching companies\"}), 404\n\n    # Step 2: Filter out inactive companies.\n    active_companies = filter_active_companies(companies)\n\n    # Step 3: Enrich each active company with LEI information.\n    enriched_results = []\n    for company in active_companies:\n        lei = await fetch_lei_info(company)\n        enriched_results.append(CompanyResult(\n            companyName=company.get(\"companyName\") or company.get(\"name\"),  # TODO: Adjust key names based on the actual response.\n            businessId=company.get(\"businessId\", \"\"),\n            companyType=company.get(\"companyType\") or \"Unknown\",  # Placeholder if not provided.\n            registrationDate=company.get(\"registrationDate\") or \"Unknown\",  # Placeholder\n            status=\"Active\",\n            lei=lei\n        ))\n\n    # Step 4: Create a payload to be cached.\n    ts = asyncio.get_event_loop().time()  # TODO: Replace with proper timestamp formatting if needed.\n    cache_payload = {\n        \"results\": enriched_results,\n        \"message\": \"Search executed successfully\",\n        \"timestamp\": ts\n    }\n\n    # Instead of storing in a local dictionary, use entity_service.add_item to cache the result.\n    # The returned id (search id) is added to the response so that the client can query using this id.\n    search_id = entity_service.add_item(\n        token=cyoda_token,\n        entity_model=\"companies\",\n        entity_version=ENTITY_VERSION,  # always use this constant\n        entity=cache_payload  # the validated data object\n    )\n\n    # Step 5: Return response.\n    return SearchResponse(\n        searchId=search_id,\n        results=enriched_results,\n        message=\"Search executed successfully\",\n        timestamp=ts\n    )\n", "action": "search_companies", "suggested_workflow": [{"start_state": "search_not_created", "end_state": "search_created", "action": "search_companies", "complete_code_for_action_derived_from_the_prototype": "\n    \"\"\"\n    POST endpoint that accepts a JSON payload with a companyName.\n    It performs an external search, filters active companies, enriches them with LEI data,\n    caches the results via entity_service.add_item, and returns a response including a searchId.\n    \"\"\"\n    company_name = data.companyName\n    if not company_name:\n        return jsonify({\"error\": \"companyName is required\"}), 400\n\n    # Step 1: Fetch companies from the external PRH API.\n    companies = await fetch_companies(company_name)\n    if not companies:\n        return jsonify({\"error\": \"No companies found or error fetching companies\"}), 404\n\n    # Step 2: Filter out inactive companies.\n    active_companies = filter_active_companies(companies)\n\n    # Step 3: Enrich each active company with LEI information.\n    enriched_results = []\n    for company in active_companies:\n        lei = await fetch_lei_info(company)\n        enriched_results.append(CompanyResult(\n            companyName=company.get(\"companyName\") or company.get(\"name\"),  # TODO: Adjust key names based on the actual response.\n            businessId=company.get(\"businessId\", \"\"),\n            companyType=company.get(\"companyType\") or \"Unknown\",  # Placeholder if not provided.\n            registrationDate=company.get(\"registrationDate\") or \"Unknown\",  # Placeholder\n            status=\"Active\",\n            lei=lei\n        ))\n\n    # Step 4: Create a payload to be cached.\n    ts = asyncio.get_event_loop().time()  # TODO: Replace with proper timestamp formatting if needed.\n    cache_payload = {\n        \"results\": enriched_results,\n        \"message\": \"Search executed successfully\",\n        \"timestamp\": ts\n    }\n\n    # Instead of storing in a local dictionary, use entity_service.add_item to cache the result.\n    # The returned id (search id) is added to the response so that the client can query using this id.\n    search_id = entity_service.add_item(\n        token=cyoda_token,\n        entity_model=\"companies\",\n        entity_version=ENTITY_VERSION,  # always use this constant\n        entity=cache_payload  # the validated data object\n    )\n\n    # Step 5: Return response.\n    return SearchResponse(\n        searchId=search_id,\n        results=enriched_results,\n        message=\"Search executed successfully\",\n        timestamp=ts\n    )\n", "description": "Create a new search.", "related_secondary_entities": ["result"]}], "related_secondary_entities": ["result"]}], "GET": [{"endpoint": "/search/<id>", "description": "Retrieve a search by ID.", "complete_code_for_action_derived_from_the_prototype": "", "related_secondary_entities": ["result"]}, {"endpoint": "/searches", "description": "Retrieve all searches entries.", "complete_code_for_action_derived_from_the_prototype": "", "related_secondary_entities": ["result"]}]}}], "secondary_entities": [{"entity_name": "result", "endpoints": {"GET": [{"endpoint": "/api/companies/result/<string:search_id>", "description": "Retrieve result information.", "complete_code_for_action_derived_from_the_prototype": "\n    \"\"\"\n    GET endpoint that retrieves a previously stored search result identified by searchId.\n    No input validation is required as there is no request body.\n    \"\"\"\n    # Retrieve the search results from the external entity service via search_id.\n    result = entity_service.get_item(\n        token=cyoda_token,\n        entity_model=\"companies\",\n        entity_version=ENTITY_VERSION,\n        technical_id=search_id\n    )\n    if not result:\n        return jsonify({\"error\": f\"Result not found for searchId: {search_id}\"}), 404\n\n    # Return the result that was cached.\n    return jsonify(result)\n"}]}}]}